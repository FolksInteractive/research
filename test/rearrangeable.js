// Generated by CoffeeScript 1.3.3
(function() {

  define(function(require, exports, module) {
    var ContainerSurface, Draggable, Easing, Engine, EventFilter, EventHandler, GridLayout, ImageSurface, ModifierChain, RenderNode, ScrollContainer, Scrollview, SequentialLayout, SnapTransition, SpringTransition, StateModifier, Surface, Timer, Transform, Transitionable, View, WallTransition, background_surface, button_snap, check_for_modifiers, clear_cell_position, color, determine_collision, i, move_to_point, scroll_content, snap, spring, surface, wall, _i, _ref,
      _this = this;
    Engine = require('famous/core/Engine');
    Surface = require('famous/core/Surface');
    View = require('famous/core/View');
    Transform = require('famous/core/Transform');
    RenderNode = require('famous/core/RenderNode');
    StateModifier = require('famous/modifiers/StateModifier');
    Easing = require('famous/transitions/Easing');
    Transitionable = require('famous/transitions/Transitionable');
    SpringTransition = require('famous/transitions/SpringTransition');
    WallTransition = require('famous/transitions/WallTransition');
    SnapTransition = require('famous/transitions/SnapTransition');
    EventHandler = require('famous/core/EventHandler');
    EventFilter = require('famous/events/EventFilter');
    Scrollview = require('famous/views/Scrollview');
    ImageSurface = require('famous/surfaces/ImageSurface');
    ContainerSurface = require('famous/surfaces/ContainerSurface');
    SequentialLayout = require('famous/views/SequentialLayout');
    ScrollContainer = require('famous/views/ScrollContainer');
    Timer = require('famous/utilities/Timer');
    Draggable = require('famous/modifiers/Draggable');
    GridLayout = require('famous/views/GridLayout');
    ModifierChain = require('famous/modifiers/ModifierChain');
    Transitionable.registerMethod('wall', WallTransition);
    Transitionable.registerMethod('spring', SpringTransition);
    Transitionable.registerMethod('snap', SnapTransition);
    wall = {
      method: 'wall',
      period: 300,
      dampingRatio: 0.3
    };
    spring = {
      method: 'spring',
      period: 300,
      dampingRatio: 0.4
    };
    snap = {
      method: 'snap',
      period: 400,
      dampingRatio: 0.6
    };
    button_snap = {
      method: 'snap',
      period: 300,
      dampingRatio: 0.4
    };
    this.event_handler = new EventHandler();
    this.context = Engine.createContext();
    this.context.setPerspective(1000);
    this.context_size = this.context.getSize();
    this.end_event = Modernizr.touch ? 'touchend' : 'mouseup';
    this.move_event = Modernizr.touch ? 'touchmove' : 'mousemove';
    this.start_event = Modernizr.touch ? 'touchstart' : 'mousedown';
    background_surface = new Surface({
      size: [void 0, void 0],
      properties: {
        backgroundColor: 'black'
      }
    });
    this.context.add(background_surface);
    this.num_cells = 12;
    this.min_width = 180;
    this.cells_x = Math.floor(this.context_size[0] / this.min_width);
    this.cells_y = Math.ceil(this.num_cells / this.cells_x);
    this.grid = new GridLayout({
      dimensions: [this.cells_x, this.cells_y]
    });
    this.grid_cells = [];
    this.grid.sequenceFrom(this.grid_cells);
    this.grid_view_grid = new ContainerSurface({
      size: [void 0, this.cells_y * 200]
    });
    this.grid_view = new View({
      size: [void 0, this.cells_y * 200]
    });
    scroll_content = [];
    this.grid_scroll = new Scrollview({
      size: [void 0, void 0]
    });
    this.grid_scroll.sequenceFrom(scroll_content);
    this.grid_view_grid.add(this.grid);
    this.grid_view.pipe(this.grid_scroll);
    this.grid_view_grid.pipe(this.grid_scroll);
    this.surfaces = [];
    this.surface_selected = null;
    for (i = _i = 0, _ref = this.num_cells - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      color = "hsl(" + (i * 360 / 16) + ",100%,50%)";
      surface = new Surface({
        size: [void 0, void 0],
        properties: {
          backgroundColor: color,
          border: '4px solid white',
          cursor: 'move'
        }
      });
      surface.pipe(this.grid_scroll);
      surface.in_front = new StateModifier({
        transform: Transform.inFront
      });
      surface.chain = new ModifierChain();
      surface.state = new StateModifier({
        size: [160, 160],
        origin: [0.5, 0.5],
        transform: Transform.translate(0, 0, 0)
      });
      surface.chain.addModifier(surface.state);
      surface.draggable = new Draggable({
        xRange: [0, this.context_size[0]],
        yRange: [0, this.context_size[1]]
      });
      surface.draggable.surface = surface;
      surface.draggable.on('start', function(e) {
        var grid_size, _j, _len, _ref1;
        if (!_this.surface_selected){
          _this.surface_selected = e.origin.surface;
          _this.surface_selected.unpipe(_this.grid_scroll);
          _this.surface_selected.view.chain.addModifier(_this.surface_selected.in_front);
          _this.surface_selected.chain.addModifier(_this.surface_selected.in_front);
          grid_size = _this.grid_view.getSize();
          _this.surface_selected.draggable.setOptions({
            xRange: [0, _this.context_size[0]],
            yRange: [0, grid_size[1]]
          });
          _this.cleared_position = _this.surface_selected.index;
          _ref1 = _this.surfaces;
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            surface = _ref1[_j];
            if (surface !== _this.surface_selected) {
              surface.setProperties({
                pointerEvents: 'none'
              });
            }
          }
          _this.surface_selected.state.halt();
          return _this.surface_selected.state.setSize([140, 140], snap);
        }
      });
      surface.draggable.on('update', function(e) {
        return determine_collision(_this.surface_selected, false);
      });
      surface.draggable.on('end', function(e) {
        var _j, _len, _ref1;
        if (_this.surface_selected) {
          _this.surface_selected.pipe(_this.grid_scroll);
          _this.surface_selected.view.chain.removeModifier(_this.surface_selected.in_front);
          _ref1 = _this.surfaces;
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            surface = _ref1[_j];
            surface.setProperties({
              pointerEvents: 'all'
            });
          }
          surface = _this.surface_selected;
          _this.surface_selected.state.halt();
          _this.surface_selected.state.setSize([160, 160], snap);
          _this.surface_selected = null;
        }
        return determine_collision(surface, true);
      });
      surface.index = i;
      surface.view = new ContainerSurface({
        size: [160, 160]
      });
      surface.view.pipe(this.grid_scroll);
      surface.pipe(surface.draggable);
      surface.view.add(surface.state).add(surface);
      surface.view.chain = new ModifierChain();
      surface.view.state = new StateModifier({
        origin: [0, 0]
      });
      surface.view.chain.addModifier(surface.view.state);
      this.grid_view.add(surface.draggable).add(surface.view.chain).add(surface.view);
      this.surfaces.push(surface);
    }
    scroll_content.push(this.grid_view);
    this.context.add(this.grid_view_grid);
    this.context.add(this.grid_scroll);
    check_for_modifiers = function() {
      var cell_size, _j, _len, _ref1;
      if (_this.grid._modifiers && _this.grid._modifiers.length > 0) {
        cell_size = _this.grid._modifiers[0].getSize();
        _ref1 = _this.surfaces;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          surface = _ref1[_j];
          move_to_point(surface, surface.index);
        }
        return Engine.removeListener('prerender', check_for_modifiers);
      }
    };
    Engine.on('prerender', check_for_modifiers);
    Engine.on('resize', function() {
      var _j, _len, _ref1, _results;
      if (_this.grid._modifiers && _this.grid._modifiers.length > 0) {
        _this.context_size = _this.context.getSize();
        _this.cells_x = Math.floor(_this.context_size[0] / _this.min_width);
        _this.cells_y = Math.ceil(_this.num_cells / _this.cells_x);
        _this.grid_view_grid.setSize([void 0, _this.cells_y * 200]);
        _this.grid_view.setOptions({
          size: [void 0, _this.cells_y * 200]
        });
        _this.grid.setOptions({
          dimensions: [_this.cells_x, _this.cells_y]
        });
        _ref1 = _this.surfaces;
        _results = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          surface = _ref1[_j];
          _results.push(move_to_point(surface, surface.index, {
            duration: 0
          }));
        }
        return _results;
      }
    });
    move_to_point = function(surface, p, transition) {
      var center, center_offset, modifier, size, surface_size, translate;
      if (!transition) {
        transition = snap;
      }
      modifier = _this.grid._modifiers[p];
      translate = Transform.interpret(modifier.getTransform())['translate'];
      size = modifier.getSize();
      center = [translate[0] + Math.round(size[0] / 2.0), translate[1] + Math.round(size[1] / 2.0), 0];
      surface_size = [160, 160];
      center_offset = [center[0] - Math.round(surface_size[0] / 2.0), center[1] - Math.round(surface_size[1] / 2.0), 0];
      return surface.draggable.setPosition(center_offset, transition, (function() {
        return this.state.setTransform(Transform.translate(0, 0, 0));
      }).bind(surface));
    };
    determine_collision = function(surface, move) {
      var index, modifier, scroll_pos, size, surface_center, surface_position, surface_size, translate, x_fit, y_fit, _j, _len, _ref1, _results;
      if (move == null) {
        move = false;
      }
      surface_size = [160, 160];
      surface_position = surface.draggable.getPosition();
      scroll_pos = _this.grid_scroll.getPosition();
      surface_center = [surface_position[0] + (surface_size[0] / 2.0), surface_position[1] + (surface_size[1] / 2.0)];
      index = 0;
      _ref1 = _this.grid._modifiers;
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        modifier = _ref1[_j];
        translate = Transform.interpret(modifier.getTransform())['translate'];
        size = modifier.getSize();
        x_fit = surface_center[0] > translate[0] && surface_center[0] < (translate[0] + size[0]);
        y_fit = surface_center[1] > translate[1] && surface_center[1] < (translate[1] + size[1]);
        if (x_fit && y_fit) {
          clear_cell_position(index);
          if (move) {
            move_to_point(surface, index);
          }
          break;
        } else {
          _results.push(index += 1);
        }
      }
      return _results;
    };
    return clear_cell_position = function(index) {
      var _j, _len, _ref1;
      if (index !== _this.cleared_position) {
        _ref1 = _this.surfaces;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          surface = _ref1[_j];
          if (surface.index > _this.cleared_position && surface.index <= index) {
            if (surface.index === 0) {
              surface.index = _this.num_cells - 1;
            } else {
              surface.index = surface.index - 1;
            }
            move_to_point(surface, surface.index);
          } else if (surface.index < _this.cleared_position && surface.index >= index) {
            if (surface.index === (_this.num_cells - 1)) {
              surface.index = 0;
            } else {
              surface.index = surface.index + 1;
            }
            move_to_point(surface, surface.index);
          }
        }
        _this.surface_selected.index = index;
        return _this.cleared_position = index;
      }
    };
  });

}).call(this);